# Generated from instruction.g4 by ANTLR 4.7.1
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\23")
        buf.write("\u0082\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\3\2\3\2\3\3\3\3\3\4\3\4\3\4\3\5\3\5\3\5\6\5\'\n")
        buf.write("\5\r\5\16\5(\5\5+\n\5\3\6\3\6\3\6\3\7\3\7\3\7\6\7\63\n")
        buf.write("\7\r\7\16\7\64\5\7\67\n\7\3\b\3\b\3\b\3\t\3\t\3\t\6\t")
        buf.write("?\n\t\r\t\16\t@\5\tC\n\t\3\n\3\n\3\n\3\n\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\5\13Q\n\13\3\f\3\f\3\f\3\f\3")
        buf.write("\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r")
        buf.write("\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3\r\3")
        buf.write("\r\3\r\5\rt\n\r\3\r\3\r\3\r\7\ry\n\r\f\r\16\r|\13\r\3")
        buf.write("\16\3\16\3\16\3\16\3\16\2\3\30\17\2\4\6\b\n\f\16\20\22")
        buf.write("\24\26\30\32\2\3\3\2\b\13\2\u0082\2\34\3\2\2\2\4\36\3")
        buf.write("\2\2\2\6 \3\2\2\2\b*\3\2\2\2\n,\3\2\2\2\f\66\3\2\2\2\16")
        buf.write("8\3\2\2\2\20B\3\2\2\2\22D\3\2\2\2\24P\3\2\2\2\26R\3\2")
        buf.write("\2\2\30s\3\2\2\2\32}\3\2\2\2\34\35\7\23\2\2\35\3\3\2\2")
        buf.write("\2\36\37\7\23\2\2\37\5\3\2\2\2 !\7\3\2\2!\"\5\2\2\2\"")
        buf.write("\7\3\2\2\2#+\5\2\2\2$&\5\2\2\2%\'\5\6\4\2&%\3\2\2\2\'")
        buf.write("(\3\2\2\2(&\3\2\2\2()\3\2\2\2)+\3\2\2\2*#\3\2\2\2*$\3")
        buf.write("\2\2\2+\t\3\2\2\2,-\7\3\2\2-.\5\4\3\2.\13\3\2\2\2/\67")
        buf.write("\5\4\3\2\60\62\5\4\3\2\61\63\5\n\6\2\62\61\3\2\2\2\63")
        buf.write("\64\3\2\2\2\64\62\3\2\2\2\64\65\3\2\2\2\65\67\3\2\2\2")
        buf.write("\66/\3\2\2\2\66\60\3\2\2\2\67\r\3\2\2\289\7\3\2\29:\5")
        buf.write("\22\n\2:\17\3\2\2\2;C\5\22\n\2<>\5\22\n\2=?\5\16\b\2>")
        buf.write("=\3\2\2\2?@\3\2\2\2@>\3\2\2\2@A\3\2\2\2AC\3\2\2\2B;\3")
        buf.write("\2\2\2B<\3\2\2\2C\21\3\2\2\2DE\5\24\13\2EF\7\4\2\2FG\5")
        buf.write("\26\f\2G\23\3\2\2\2HI\7\r\2\2IJ\7\5\2\2JK\5\30\r\2KL\7")
        buf.write("\3\2\2LM\5\30\r\2MN\7\6\2\2NQ\3\2\2\2OQ\7\22\2\2PH\3\2")
        buf.write("\2\2PO\3\2\2\2Q\25\3\2\2\2RS\5\2\2\2ST\7\7\2\2TU\5\30")
        buf.write("\r\2U\27\3\2\2\2VW\b\r\1\2Wt\5\2\2\2Xt\5\4\3\2YZ\7\5\2")
        buf.write("\2Z[\5\30\r\2[\\\7\6\2\2\\t\3\2\2\2]^\7\16\2\2^_\7\5\2")
        buf.write("\2_`\5\30\r\2`a\7\3\2\2ab\5\30\r\2bc\7\3\2\2cd\5\30\r")
        buf.write("\2de\7\6\2\2et\3\2\2\2fg\7\17\2\2gh\7\5\2\2hi\5\30\r\2")
        buf.write("ij\7\3\2\2jk\5\30\r\2kl\7\6\2\2lt\3\2\2\2mn\7\20\2\2n")
        buf.write("o\7\5\2\2op\5\30\r\2pq\7\6\2\2qt\3\2\2\2rt\7\21\2\2sV")
        buf.write("\3\2\2\2sX\3\2\2\2sY\3\2\2\2s]\3\2\2\2sf\3\2\2\2sm\3\2")
        buf.write("\2\2sr\3\2\2\2tz\3\2\2\2uv\f\b\2\2vw\t\2\2\2wy\5\30\r")
        buf.write("\txu\3\2\2\2y|\3\2\2\2zx\3\2\2\2z{\3\2\2\2{\31\3\2\2\2")
        buf.write("|z\3\2\2\2}~\5\b\5\2~\177\5\f\7\2\177\u0080\5\20\t\2\u0080")
        buf.write("\33\3\2\2\2\13(*\64\66@BPsz")
        return buf.getvalue()


class instructionParser ( Parser ):

    grammarFileName = "instruction.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "','", "':'", "'('", "')'", "'='", "'+'", 
                     "'-'", "'*'", "'/'", "<INVALID>", "'rel_op'", "'Mux3'", 
                     "'Mux2'", "'Opt'", "'C()'", "'True'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "WS", "RELOP", "MUX3", "MUX2", 
                      "OPT", "CONSTANT", "TRUE", "ID" ]

    RULE_state_var = 0
    RULE_packet_field = 1
    RULE_state_var_with_comma = 2
    RULE_state_vars = 3
    RULE_packet_field_with_comma = 4
    RULE_packet_fields = 5
    RULE_guarded_update_with_comma = 6
    RULE_guarded_updates = 7
    RULE_guarded_update = 8
    RULE_guard = 9
    RULE_update = 10
    RULE_expr = 11
    RULE_instruction = 12

    ruleNames =  [ "state_var", "packet_field", "state_var_with_comma", 
                   "state_vars", "packet_field_with_comma", "packet_fields", 
                   "guarded_update_with_comma", "guarded_updates", "guarded_update", 
                   "guard", "update", "expr", "instruction" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    WS=10
    RELOP=11
    MUX3=12
    MUX2=13
    OPT=14
    CONSTANT=15
    TRUE=16
    ID=17

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.1")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class State_varContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(instructionParser.ID, 0)

        def getRuleIndex(self):
            return instructionParser.RULE_state_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_var" ):
                listener.enterState_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_var" ):
                listener.exitState_var(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitState_var" ):
                return visitor.visitState_var(self)
            else:
                return visitor.visitChildren(self)




    def state_var(self):

        localctx = instructionParser.State_varContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_state_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 26
            self.match(instructionParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Packet_fieldContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ID(self):
            return self.getToken(instructionParser.ID, 0)

        def getRuleIndex(self):
            return instructionParser.RULE_packet_field

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPacket_field" ):
                listener.enterPacket_field(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPacket_field" ):
                listener.exitPacket_field(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPacket_field" ):
                return visitor.visitPacket_field(self)
            else:
                return visitor.visitChildren(self)




    def packet_field(self):

        localctx = instructionParser.Packet_fieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_packet_field)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 28
            self.match(instructionParser.ID)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_var_with_commaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_var(self):
            return self.getTypedRuleContext(instructionParser.State_varContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_state_var_with_comma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_var_with_comma" ):
                listener.enterState_var_with_comma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_var_with_comma" ):
                listener.exitState_var_with_comma(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitState_var_with_comma" ):
                return visitor.visitState_var_with_comma(self)
            else:
                return visitor.visitChildren(self)




    def state_var_with_comma(self):

        localctx = instructionParser.State_var_with_commaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_state_var_with_comma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 30
            self.match(instructionParser.T__0)
            self.state = 31
            self.state_var()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_varsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_var(self):
            return self.getTypedRuleContext(instructionParser.State_varContext,0)


        def state_var_with_comma(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.State_var_with_commaContext)
            else:
                return self.getTypedRuleContext(instructionParser.State_var_with_commaContext,i)


        def getRuleIndex(self):
            return instructionParser.RULE_state_vars

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_vars" ):
                listener.enterState_vars(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_vars" ):
                listener.exitState_vars(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitState_vars" ):
                return visitor.visitState_vars(self)
            else:
                return visitor.visitChildren(self)




    def state_vars(self):

        localctx = instructionParser.State_varsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_state_vars)
        self._la = 0 # Token type
        try:
            self.state = 40
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 33
                self.state_var()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 34
                self.state_var()
                self.state = 36 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 35
                    self.state_var_with_comma()
                    self.state = 38 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==instructionParser.T__0):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Packet_field_with_commaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def packet_field(self):
            return self.getTypedRuleContext(instructionParser.Packet_fieldContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_packet_field_with_comma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPacket_field_with_comma" ):
                listener.enterPacket_field_with_comma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPacket_field_with_comma" ):
                listener.exitPacket_field_with_comma(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPacket_field_with_comma" ):
                return visitor.visitPacket_field_with_comma(self)
            else:
                return visitor.visitChildren(self)




    def packet_field_with_comma(self):

        localctx = instructionParser.Packet_field_with_commaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_packet_field_with_comma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 42
            self.match(instructionParser.T__0)
            self.state = 43
            self.packet_field()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Packet_fieldsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def packet_field(self):
            return self.getTypedRuleContext(instructionParser.Packet_fieldContext,0)


        def packet_field_with_comma(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.Packet_field_with_commaContext)
            else:
                return self.getTypedRuleContext(instructionParser.Packet_field_with_commaContext,i)


        def getRuleIndex(self):
            return instructionParser.RULE_packet_fields

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPacket_fields" ):
                listener.enterPacket_fields(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPacket_fields" ):
                listener.exitPacket_fields(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPacket_fields" ):
                return visitor.visitPacket_fields(self)
            else:
                return visitor.visitChildren(self)




    def packet_fields(self):

        localctx = instructionParser.Packet_fieldsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_packet_fields)
        self._la = 0 # Token type
        try:
            self.state = 52
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 45
                self.packet_field()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 46
                self.packet_field()
                self.state = 48 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 47
                    self.packet_field_with_comma()
                    self.state = 50 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==instructionParser.T__0):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Guarded_update_with_commaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guarded_update(self):
            return self.getTypedRuleContext(instructionParser.Guarded_updateContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_guarded_update_with_comma

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuarded_update_with_comma" ):
                listener.enterGuarded_update_with_comma(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuarded_update_with_comma" ):
                listener.exitGuarded_update_with_comma(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuarded_update_with_comma" ):
                return visitor.visitGuarded_update_with_comma(self)
            else:
                return visitor.visitChildren(self)




    def guarded_update_with_comma(self):

        localctx = instructionParser.Guarded_update_with_commaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_guarded_update_with_comma)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 54
            self.match(instructionParser.T__0)
            self.state = 55
            self.guarded_update()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Guarded_updatesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guarded_update(self):
            return self.getTypedRuleContext(instructionParser.Guarded_updateContext,0)


        def guarded_update_with_comma(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.Guarded_update_with_commaContext)
            else:
                return self.getTypedRuleContext(instructionParser.Guarded_update_with_commaContext,i)


        def getRuleIndex(self):
            return instructionParser.RULE_guarded_updates

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuarded_updates" ):
                listener.enterGuarded_updates(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuarded_updates" ):
                listener.exitGuarded_updates(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuarded_updates" ):
                return visitor.visitGuarded_updates(self)
            else:
                return visitor.visitChildren(self)




    def guarded_updates(self):

        localctx = instructionParser.Guarded_updatesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_guarded_updates)
        self._la = 0 # Token type
        try:
            self.state = 64
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 57
                self.guarded_update()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 58
                self.guarded_update()
                self.state = 60 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 59
                    self.guarded_update_with_comma()
                    self.state = 62 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==instructionParser.T__0):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Guarded_updateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def guard(self):
            return self.getTypedRuleContext(instructionParser.GuardContext,0)


        def update(self):
            return self.getTypedRuleContext(instructionParser.UpdateContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_guarded_update

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGuarded_update" ):
                listener.enterGuarded_update(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGuarded_update" ):
                listener.exitGuarded_update(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitGuarded_update" ):
                return visitor.visitGuarded_update(self)
            else:
                return visitor.visitChildren(self)




    def guarded_update(self):

        localctx = instructionParser.Guarded_updateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_guarded_update)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 66
            self.guard()
            self.state = 67
            self.match(instructionParser.T__1)
            self.state = 68
            self.update()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class GuardContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return instructionParser.RULE_guard

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RelOpContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.GuardContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def RELOP(self):
            return self.getToken(instructionParser.RELOP, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.ExprContext)
            else:
                return self.getTypedRuleContext(instructionParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRelOp" ):
                listener.enterRelOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRelOp" ):
                listener.exitRelOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitRelOp" ):
                return visitor.visitRelOp(self)
            else:
                return visitor.visitChildren(self)


    class TrueContext(GuardContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.GuardContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE(self):
            return self.getToken(instructionParser.TRUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrue" ):
                listener.enterTrue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrue" ):
                listener.exitTrue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrue" ):
                return visitor.visitTrue(self)
            else:
                return visitor.visitChildren(self)



    def guard(self):

        localctx = instructionParser.GuardContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_guard)
        try:
            self.state = 78
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [instructionParser.RELOP]:
                localctx = instructionParser.RelOpContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 70
                self.match(instructionParser.RELOP)
                self.state = 71
                self.match(instructionParser.T__2)
                self.state = 72
                self.expr(0)
                self.state = 73
                self.match(instructionParser.T__0)
                self.state = 74
                self.expr(0)
                self.state = 75
                self.match(instructionParser.T__3)
                pass
            elif token in [instructionParser.TRUE]:
                localctx = instructionParser.TrueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 77
                self.match(instructionParser.TRUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UpdateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_var(self):
            return self.getTypedRuleContext(instructionParser.State_varContext,0)


        def expr(self):
            return self.getTypedRuleContext(instructionParser.ExprContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_update

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate" ):
                listener.enterUpdate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate" ):
                listener.exitUpdate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitUpdate" ):
                return visitor.visitUpdate(self)
            else:
                return visitor.visitChildren(self)




    def update(self):

        localctx = instructionParser.UpdateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_update)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 80
            self.state_var()
            self.state = 81
            self.match(instructionParser.T__4)
            self.state = 82
            self.expr(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExprContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return instructionParser.RULE_expr

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class PacketFieldContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def packet_field(self):
            return self.getTypedRuleContext(instructionParser.Packet_fieldContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPacketField" ):
                listener.enterPacketField(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPacketField" ):
                listener.exitPacketField(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPacketField" ):
                return visitor.visitPacketField(self)
            else:
                return visitor.visitChildren(self)


    class ExprWithOpContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.ExprContext)
            else:
                return self.getTypedRuleContext(instructionParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprWithOp" ):
                listener.enterExprWithOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprWithOp" ):
                listener.exitExprWithOp(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprWithOp" ):
                return visitor.visitExprWithOp(self)
            else:
                return visitor.visitChildren(self)


    class OptContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def OPT(self):
            return self.getToken(instructionParser.OPT, 0)
        def expr(self):
            return self.getTypedRuleContext(instructionParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOpt" ):
                listener.enterOpt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOpt" ):
                listener.exitOpt(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitOpt" ):
                return visitor.visitOpt(self)
            else:
                return visitor.visitChildren(self)


    class Mux2Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MUX2(self):
            return self.getToken(instructionParser.MUX2, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.ExprContext)
            else:
                return self.getTypedRuleContext(instructionParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMux2" ):
                listener.enterMux2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMux2" ):
                listener.exitMux2(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMux2" ):
                return visitor.visitMux2(self)
            else:
                return visitor.visitChildren(self)


    class ConstantContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def CONSTANT(self):
            return self.getToken(instructionParser.CONSTANT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstant" ):
                listener.enterConstant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstant" ):
                listener.exitConstant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConstant" ):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)


    class Mux3Context(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def MUX3(self):
            return self.getToken(instructionParser.MUX3, 0)
        def expr(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(instructionParser.ExprContext)
            else:
                return self.getTypedRuleContext(instructionParser.ExprContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMux3" ):
                listener.enterMux3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMux3" ):
                listener.exitMux3(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMux3" ):
                return visitor.visitMux3(self)
            else:
                return visitor.visitChildren(self)


    class StateVarContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_var(self):
            return self.getTypedRuleContext(instructionParser.State_varContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStateVar" ):
                listener.enterStateVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStateVar" ):
                listener.exitStateVar(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitStateVar" ):
                return visitor.visitStateVar(self)
            else:
                return visitor.visitChildren(self)


    class ExprWithParenContext(ExprContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a instructionParser.ExprContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expr(self):
            return self.getTypedRuleContext(instructionParser.ExprContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExprWithParen" ):
                listener.enterExprWithParen(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExprWithParen" ):
                listener.exitExprWithParen(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitExprWithParen" ):
                return visitor.visitExprWithParen(self)
            else:
                return visitor.visitChildren(self)



    def expr(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = instructionParser.ExprContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 22
        self.enterRecursionRule(localctx, 22, self.RULE_expr, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 113
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
            if la_ == 1:
                localctx = instructionParser.StateVarContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 85
                self.state_var()
                pass

            elif la_ == 2:
                localctx = instructionParser.PacketFieldContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 86
                self.packet_field()
                pass

            elif la_ == 3:
                localctx = instructionParser.ExprWithParenContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 87
                self.match(instructionParser.T__2)
                self.state = 88
                self.expr(0)
                self.state = 89
                self.match(instructionParser.T__3)
                pass

            elif la_ == 4:
                localctx = instructionParser.Mux3Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 91
                self.match(instructionParser.MUX3)
                self.state = 92
                self.match(instructionParser.T__2)
                self.state = 93
                self.expr(0)
                self.state = 94
                self.match(instructionParser.T__0)
                self.state = 95
                self.expr(0)
                self.state = 96
                self.match(instructionParser.T__0)
                self.state = 97
                self.expr(0)
                self.state = 98
                self.match(instructionParser.T__3)
                pass

            elif la_ == 5:
                localctx = instructionParser.Mux2Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 100
                self.match(instructionParser.MUX2)
                self.state = 101
                self.match(instructionParser.T__2)
                self.state = 102
                self.expr(0)
                self.state = 103
                self.match(instructionParser.T__0)
                self.state = 104
                self.expr(0)
                self.state = 105
                self.match(instructionParser.T__3)
                pass

            elif la_ == 6:
                localctx = instructionParser.OptContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 107
                self.match(instructionParser.OPT)
                self.state = 108
                self.match(instructionParser.T__2)
                self.state = 109
                self.expr(0)
                self.state = 110
                self.match(instructionParser.T__3)
                pass

            elif la_ == 7:
                localctx = instructionParser.ConstantContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 112
                self.match(instructionParser.CONSTANT)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 120
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = instructionParser.ExprWithOpContext(self, instructionParser.ExprContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expr)
                    self.state = 115
                    if not self.precpred(self._ctx, 6):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                    self.state = 116
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << instructionParser.T__5) | (1 << instructionParser.T__6) | (1 << instructionParser.T__7) | (1 << instructionParser.T__8))) != 0)):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 117
                    self.expr(7) 
                self.state = 122
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class InstructionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def state_vars(self):
            return self.getTypedRuleContext(instructionParser.State_varsContext,0)


        def packet_fields(self):
            return self.getTypedRuleContext(instructionParser.Packet_fieldsContext,0)


        def guarded_updates(self):
            return self.getTypedRuleContext(instructionParser.Guarded_updatesContext,0)


        def getRuleIndex(self):
            return instructionParser.RULE_instruction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInstruction" ):
                listener.enterInstruction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInstruction" ):
                listener.exitInstruction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInstruction" ):
                return visitor.visitInstruction(self)
            else:
                return visitor.visitChildren(self)




    def instruction(self):

        localctx = instructionParser.InstructionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_instruction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 123
            self.state_vars()
            self.state = 124
            self.packet_fields()
            self.state = 125
            self.guarded_updates()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[11] = self.expr_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expr_sempred(self, localctx:ExprContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 6)
         




